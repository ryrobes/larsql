# FUTURE: Map Cascade Tool Demo
#
# This demonstrates what a dedicated map_cascade tool would look like.
# THIS DOES NOT WORK YET - it's a design proposal!
#
# To implement:
#   1. Create map_cascade tool in eddies/system.py
#   2. Register in __init__.py
#   3. Update runner to handle array results

cascade_id: map_cascade_demo
description: >
  PROPOSED: Dynamic mapping using dedicated map_cascade tool.
  This is cleaner than soundings for pure data fan-out.

phases:
  # Phase 1: List work items (could be files, customers, URLs, etc.)
  - name: list_customers
    tool: sql_data
    inputs:
      query: |
        SELECT
          customer_id,
          customer_name,
          region
        FROM (VALUES
          (1001, 'Acme Corp', 'US-West'),
          (1002, 'Globex Ltd', 'EU'),
          (1003, 'Initech', 'US-East'),
          (1004, 'Umbrella Co', 'Asia')
        ) AS t(customer_id, customer_name, region)
    # Creates _list_customers temp table

  # Phase 2: Process each customer (fan-out)
  - name: process_customers
    tool: map_cascade  # NEW: Dedicated mapping tool
    inputs:
      cascade: "traits/customer_analytics.yaml"

      # Array to map over - each item spawns one cascade
      map_over: |
        SELECT customer_id, customer_name, region
        FROM _list_customers

      # How to inject data into each cascade
      input_mapping:
        customer_id: "{{ row.customer_id }}"
        customer_name: "{{ row.customer_name }}"
        region: "{{ row.region }}"

      # Execution options
      max_parallel: 5  # Limit concurrent cascades
      mode: aggregate  # How to collect results

      # Error handling
      on_error: continue  # or "fail_fast", "collect_errors"
      retry_failed: true

      # Timeout per cascade
      timeout: "5m"

    # Result: Array of cascade outputs
    # [
    #   {"customer_id": 1001, "revenue": 50000, "churn_risk": 0.2},
    #   {"customer_id": 1002, "revenue": 75000, "churn_risk": 0.1},
    #   ...
    # ]

  # Phase 3: Load results back to SQL for analysis
  - name: analyze_results
    tool: python_data
    inputs:
      code: |
        import duckdb
        results = {{ outputs.process_customers }}

        # Convert to DuckDB table
        conn = duckdb.connect()
        conn.execute("""
          CREATE TEMP TABLE customer_results AS
          SELECT * FROM results
        """)

        # Aggregate insights
        summary = conn.execute("""
          SELECT
            region,
            COUNT(*) as customer_count,
            SUM(revenue) as total_revenue,
            AVG(churn_risk) as avg_churn_risk
          FROM customer_results
          GROUP BY region
          ORDER BY total_revenue DESC
        """).fetchall()

        return {
          "summary": summary,
          "high_risk_customers": conn.execute("""
            SELECT customer_name, churn_risk
            FROM customer_results
            WHERE churn_risk > 0.5
            ORDER BY churn_risk DESC
          """).fetchall()
        }

  # Phase 4: Generate report
  - name: report
    instructions: |
      Create executive summary from customer analytics results.

      Summary data: {{ outputs.analyze_results.summary }}
      High-risk customers: {{ outputs.analyze_results.high_risk_customers }}

      Include:
      - Revenue by region
      - Churn risk insights
      - Recommended actions

    traits: []

---
# traits/customer_analytics.yaml (referenced above)
cascade_id: customer_analytics
description: Analyze single customer metrics

inputs_schema:
  customer_id: "Unique customer identifier"
  customer_name: "Customer company name"
  region: "Geographic region"

phases:
  - name: fetch_transactions
    tool: sql_data
    inputs:
      query: |
        -- In production, this would query real database
        SELECT
          '{{ input.customer_id }}' as customer_id,
          50000 + (random() * 50000) as revenue,
          random() as churn_risk

  - name: enrich_with_llm
    instructions: |
      Based on this customer data:
      - Name: {{ input.customer_name }}
      - Region: {{ input.region }}
      - Revenue: {{ outputs.fetch_transactions.revenue }}

      Provide:
      1. Risk assessment (0-1 scale)
      2. Recommended retention actions
      3. Upsell opportunities

      Return as JSON:
      {
        "customer_id": {{ input.customer_id }},
        "revenue": revenue_value,
        "churn_risk": 0.XX,
        "recommendations": ["action1", "action2"]
      }

    traits: []
