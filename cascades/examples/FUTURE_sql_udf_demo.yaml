# FUTURE: SQL UDF for LLM-Powered Data Enrichment
#
# This demonstrates rvbbit() - a SQL function that spawns mini LLM phases.
# THIS DOES NOT WORK YET - it's a research proposal!
#
# Concept: Bring LLMs into SQL queries for row-by-row data enrichment.

cascade_id: sql_udf_demo
description: >
  RESEARCH: LLM-powered SQL UDF for inline data enrichment.
  This would be a killer feature - no other orchestrator does this!

phases:
  # Phase 1: Load raw product data
  - name: load_products
    tool: sql_data
    inputs:
      query: |
        SELECT * FROM (VALUES
          ('Apple iPhone 15 Pro Max 256GB Space Black', 'Electronics', 1199.99),
          ('Samsung Galaxy S24 Ultra Titanium Gray', 'Electronics', 1299.99),
          ('Levi''s 501 Original Fit Jeans - Blue', 'Clothing', 59.99),
          ('KitchenAid Artisan Stand Mixer Red', 'Home & Kitchen', 429.99),
          ('Sony WH-1000XM5 Noise Canceling Headphones', 'Electronics', 399.99),
          ('The North Face Thermoball Jacket Black', 'Clothing', 229.00),
          ('Dyson V15 Detect Cordless Vacuum', 'Home & Kitchen', 749.99)
        ) AS products(name, category, price)
    # Creates _load_products temp table

  # Phase 2: Enrich with LLM - extract structured attributes
  - name: enrich_products
    tool: sql_data
    inputs:
      query: |
        SELECT
          name,
          category,
          price,

          -- NEW: rvbbit() spawns mini LLM phase per row
          rvbbit(
            'Extract the brand name from this product title. Return just the brand, nothing else.',
            name
          ) as brand,

          rvbbit(
            'Extract the color from this product title. If no color mentioned, return NULL.',
            name
          ) as color,

          rvbbit(
            'Extract the model/version number if present. Return NULL if not found.',
            name
          ) as model,

          rvbbit(
            'Classify this product as: flagship, mid-range, budget, or luxury. Return just one word.',
            name || ' - $' || price
          ) as price_tier,

          rvbbit(
            'Generate a 3-5 word marketing tagline for this product.',
            name
          ) as tagline

        FROM _load_products

      # UDF configuration
      llm_config:
        model: "anthropic/claude-haiku-4.5"  # Fast, cheap model for simple extraction
        temperature: 0  # Deterministic
        max_parallel: 10  # Process 10 rows concurrently
        cache_results: true  # Same input = same output (saves $$)

    # Creates _enrich_products temp table with LLM-enriched columns

  # Phase 3: Advanced analytics with enriched data
  - name: brand_analysis
    tool: sql_data
    inputs:
      query: |
        SELECT
          brand,
          COUNT(*) as product_count,
          AVG(price) as avg_price,
          MIN(price_tier) as most_common_tier
        FROM _enrich_products
        GROUP BY brand
        ORDER BY product_count DESC, avg_price DESC

  # Phase 4: Complex LLM aggregation
  - name: competitive_analysis
    tool: sql_data
    inputs:
      query: |
        WITH competitor_products AS (
          SELECT
            brand,
            category,
            STRING_AGG(name || ' ($' || price || ')', ', ') as products
          FROM _enrich_products
          WHERE category = 'Electronics'
          GROUP BY brand, category
        )
        SELECT
          brand,
          products,

          -- UDF can take aggregated data too!
          rvbbit(
            'Analyze this brand''s product lineup. Identify: 1) Price positioning strategy, 2) Target market, 3) Product gaps. Return as JSON with keys: strategy, target_market, gaps.',
            'Brand: ' || brand || '. Products: ' || products
          ) as analysis

        FROM competitor_products

      llm_config:
        model: "anthropic/claude-sonnet-4.5"  # Smarter model for analysis
        temperature: 0.3

  # Phase 5: Generate final report with insights
  - name: report
    instructions: |
      Create executive summary from product analysis.

      Brand breakdown: {{ outputs.brand_analysis }}
      Competitive analysis: {{ outputs.competitive_analysis }}

      Include:
      1. Brand positioning map
      2. Pricing strategy insights
      3. Market opportunity gaps
      4. Recommended product additions

    traits: []

---
# How rvbbit() would work under the hood:

# 1. SQL Parser Integration
#    - DuckDB's UDF registration system
#    - Parse UDF calls from SQL query
#    - Extract: instructions, input column, config

# 2. Execution Strategy
#    - Batch rows for efficiency (process 10 at a time)
#    - Spawn mini LLM phase per row/batch
#    - Cache results (hash input â†’ output mapping)
#    - Parallel execution up to max_parallel

# 3. Result Handling
#    - Return scalar (string, number) or JSON object
#    - Handle errors gracefully (NULL on failure)
#    - Log each UDF call to unified logs

# 4. Caching Layer
#    - Key: hash(instructions + input + model)
#    - Value: LLM output
#    - Storage: DuckDB table or Redis
#    - TTL: configurable (default: session-scoped)

# Example implementation sketch:

def register_rvbbit(connection):
    """Register rvbbit as DuckDB user-defined function."""

    def rvbbit(instructions: str, input_value: str, config: dict = None) -> str:
        # Check cache
        cache_key = hash((instructions, input_value, config.get('model')))
        if cached := get_cache(cache_key):
            return cached

        # Spawn mini LLM phase
        from windlass.runner import run_llm_turn
        result = run_llm_turn(
            instructions=instructions,
            input_data={"value": input_value},
            model=config.get('model', 'anthropic/claude-haiku-4.5'),
            temperature=config.get('temperature', 0),
            max_tokens=config.get('max_tokens', 500)
        )

        # Cache result
        set_cache(cache_key, result)

        return result

    # Register as DuckDB UDF
    connection.create_function(
        "rvbbit",
        rvbbit,
        parameters=['VARCHAR', 'VARCHAR'],
        return_type='VARCHAR',
        type='native'
    )

# Why this is powerful:

# 1. SQL Composability
#    - WHERE rvbbit(...) LIKE '%enterprise%'
#    - JOIN ON udf_output = other_table.key
#    - GROUP BY, ORDER BY enriched columns

# 2. Zero-Copy Data Flow
#    - No serialization between phases
#    - Temp tables stay in DuckDB
#    - LLM enriches in-place

# 3. Novel Use Cases
#    - Data cleaning: "Fix this malformed address"
#    - Entity extraction: "Extract person name from this text"
#    - Classification: "Categorize this support ticket"
#    - Sentiment: "Rate sentiment 1-5"
#    - Translation: "Translate to Spanish"

# 4. Cost Efficiency
#    - Caching prevents duplicate LLM calls
#    - Batch processing amortizes latency
#    - Cheap models for simple tasks (Haiku)

# Example use cases:

# A. Data Cleaning
SELECT
  email,
  rvbbit(
    'Fix this email address if malformed. Return cleaned email or NULL if invalid.',
    email
  ) as cleaned_email
FROM messy_user_data

# B. Entity Extraction
SELECT
  support_ticket_text,
  rvbbit(
    'Extract customer name from this support ticket. Return just the name.',
    support_ticket_text
  ) as customer_name,
  rvbbit(
    'Extract product name mentioned. Return NULL if none.',
    support_ticket_text
  ) as product_mentioned
FROM support_tickets

# C. Sentiment Analysis
SELECT
  review_text,
  review_date,
  rvbbit(
    'Rate sentiment: positive, negative, or neutral. Return just one word.',
    review_text
  ) as sentiment,
  CAST(rvbbit(
    'Rate this review 1-5 stars based on sentiment. Return just the number.',
    review_text
  ) AS INTEGER) as sentiment_score
FROM product_reviews

# D. Data Enrichment
SELECT
  company_name,
  rvbbit(
    'Identify the industry for this company. Return just the industry name.',
    company_name
  ) as industry,
  rvbbit(
    'Estimate company size: startup, small, medium, large, enterprise. Return one word.',
    company_name
  ) as estimated_size
FROM companies

# E. Complex JSON Extraction
SELECT
  product_description,
  rvbbit(
    'Extract features as JSON array. Return: {"features": ["feature1", "feature2", ...]}',
    product_description
  )::JSON as features_json
FROM products

# This would be genuinely novel - I'm not aware of ANY orchestrator doing LLM SQL UDFs!
