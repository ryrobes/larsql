cascade_id: clojure_functional_demo
description: Demonstrates Clojure's elegant functional data processing with transducers,
  threading macros, and immutable transformations.
inputs_schema: {}
cells:
- name: source_data
  tool: sql_data
  inputs:
    query: "-- Generate order data for functional processing\nSELECT * FROM (\n  VALUES\n\
      \    ('ORD001', 'alice@example.com', 'laptop', 1200.00, 1, 'shipped'),\n   \
      \ ('ORD002', 'bob@example.com', 'mouse', 25.00, 2, 'delivered'),\n    ('ORD003',\
      \ 'alice@example.com', 'keyboard', 75.00, 1, 'shipped'),\n    ('ORD004', 'charlie@example.com',\
      \ 'monitor', 400.00, 1, 'pending'),\n    ('ORD005', 'bob@example.com', 'headphones',\
      \ 150.00, 1, 'delivered'),\n    ('ORD006', 'diana@example.com', 'laptop', 1200.00,\
      \ 2, 'shipped'),\n    ('ORD007', 'alice@example.com', 'webcam', 80.00, 1, 'delivered'),\n\
      \    ('ORD008', 'charlie@example.com', 'desk', 350.00, 1, 'pending'),\n    ('ORD009',\
      \ 'diana@example.com', 'chair', 250.00, 2, 'shipped'),\n    ('ORD010', 'bob@example.com',\
      \ 'monitor', 400.00, 1, 'cancelled')\n) AS t(order_id, email, product, price,\
      \ quantity, status)\n"
  handoffs:
  - clojure_transform
- name: clojure_transform
  tool: clojure_data
  inputs:
    code: ";; Functional order processing with Clojure\n;; Note: phase names are keywords\
      \ in kebab-case (source_data -> :source-data)\n(let [orders (:source-data data)\n\
      \n      ;; Add computed fields using threading macro\n      enriched-orders\n\
      \      (->> orders\n           (map #(assoc %\n                   :total (*\
      \ (:price %) (:quantity %))\n                   :customer (first (clojure.string/split\
      \ (:email %) #\"@\")))))\n\n      ;; Filter active orders (not cancelled)\n\
      \      active-orders\n      (filter #(not= (:status %) \"cancelled\") enriched-orders)\n\
      \n      ;; Group by customer with aggregations\n      by-customer\n      (reduce\n\
      \        (fn [acc order]\n          (let [cust (:customer order)]\n        \
      \    (update acc cust\n                    (fnil (fn [prev]\n              \
      \              {:customer cust\n                             :email (:email\
      \ order)\n                             :order_count (inc (:order_count prev))\n\
      \                             :total_spent (+ (:total_spent prev) (:total order))\n\
      \                             :products (conj (:products prev) (:product order))\n\
      \                             :statuses (conj (:statuses prev) (:status order))})\n\
      \                          {:order_count 0 :total_spent 0 :products [] :statuses\
      \ []}))))\n        {}\n        active-orders)]\n\n  ;; Return as vector sorted\
      \ by total spent\n  (->> (vals by-customer)\n       (sort-by :total_spent >)\n\
      \       vec))\n"
  handoffs:
  - clojure_analytics
- name: clojure_analytics
  tool: clojure_data
  inputs:
    code: ";; Advanced analytics with reduce and transducers\n(let [customers (:clojure-transform\
      \ data)\n\n      ;; Calculate customer tiers using cond threading\n      with-tiers\n\
      \      (mapv\n        (fn [c]\n          (let [spent (:total_spent c)\n    \
      \            tier (cond\n                       (>= spent 2000) {:tier \"VIP\"\
      \ :discount 0.20}\n                       (>= spent 500)  {:tier \"Gold\" :discount\
      \ 0.10}\n                       :else           {:tier \"Standard\" :discount\
      \ 0.05})]\n            (merge c tier {:unique_products (count (distinct (:products\
      \ c)))})))\n        customers)\n\n      ;; Aggregate tier statistics\n     \
      \ tier-stats\n      (->> with-tiers\n           (group-by :tier)\n         \
      \  (map (fn [[tier members]]\n                  {:tier tier\n              \
      \     :customer_count (count members)\n                   :total_revenue (reduce\
      \ + (map :total_spent members))\n                   :avg_order_count (float\
      \ (/ (reduce + (map :order_count members))\n                               \
      \               (count members)))})))\n\n      ;; Overall summary\n      summary\
      \ {:tier_breakdown (vec tier-stats)\n               :total_customers (count\
      \ with-tiers)\n               :total_revenue (reduce + (map :total_spent with-tiers))\n\
      \               :customer_details with-tiers}]\n\n  summary)\n"
  handoffs:
  - final_sql
- name: final_sql
  tool: sql_data
  inputs:
    query: "-- Query customer details from Clojure result\n-- Dict results with nested\
      \ arrays create tables: _phase_key\n-- e.g., {customer_details: [...]} -> _clojure_analytics_customer_details\n\
      \nSELECT\n  customer,\n  tier,\n  ROUND(discount * 100) || '%' as discount,\n\
      \  order_count as orders,\n  total_spent,\n  unique_products,\n  products as\
      \ product_list\nFROM _clojure_analytics_customer_details\nORDER BY total_spent\
      \ DESC\n"
