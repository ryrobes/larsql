cascade_id: semantic_embed

description: |
  Generate text embeddings using Agent.embed().

  Uses RVBBIT_DEFAULT_EMBED_MODEL (qwen/qwen3-embedding-8b, 4096 dims).
  Results are cached by input hash for performance.

  SQL Usage:
    SELECT id, text, EMBED(text) as embedding FROM documents;
    SELECT id, EMBED(text, 'custom-model') as embedding FROM documents;

  Performance:
    - First call: ~100ms per text (API latency)
    - Cached calls: <1ms (instant return)
    - Batching: Agent.embed() handles automatically (50 texts/call)

inputs_schema:
  text: "Text to embed (required)"
  model: "Optional model override (default qwen/qwen3-embedding-8b)"

sql_function:
  name: semantic_embed
  description: Generate 4096-dim embedding vector from text
  args:
    - name: text
      type: VARCHAR
      description: "Text to embed"
    - name: model
      type: VARCHAR
      optional: true
      description: "Optional embedding model name"
  returns: DOUBLE[]  # Array of floats (DuckDB type)
  shape: SCALAR
  operators:
    - "EMBED({{ text }})"
    - "EMBED({{ text }}, '{{ model }}')"
  cache: true  # Cache embeddings by input hash
  context_arg: text  # Which arg provides context for token counting

cells:
  - name: generate_and_store
    tool: python_data
    inputs:
      code: |
        # Generate embedding and store in ClickHouse for VECTOR_SEARCH
        from rvbbit.traits.embedding_storage import agent_embed, clickhouse_store_embedding
        import hashlib

        text = input.get('text', '')
        model = input.get('model')

        # Generate embedding
        embed_result = agent_embed(text=text, model=model)
        embedding = embed_result['embedding']

        # Store in rvbbit_embeddings for future VECTOR_SEARCH queries
        # We don't know the actual source_table/source_id here (just called from SELECT EMBED(col))
        # So we use the text hash as a unique ID
        text_hash = hashlib.md5(text.encode()).hexdigest()[:16]

        try:
            clickhouse_store_embedding(
                source_table='_embed_cache',  # Special table for ad-hoc EMBED() calls
                source_id=text_hash,
                text=text,
                embedding=embedding,
                model=embed_result['model']
            )
        except Exception as e:
            # Log but don't fail if storage fails
            import logging
            logging.getLogger(__name__).warning(f"Could not store embedding: {e}")

        # Return embedding for SQL
        result = embedding
    context:
      enabled: false
