# PARSE - General-purpose text extraction with natural language
#
# The universal parser. Extract anything from text using plain English.
# Uses structural caching: generates SQL once per input shape, reuses for similar inputs.
#
# SQL Usage:
#   SELECT PARSE(email_body, 'the deadline date') FROM emails
#   SELECT PARSE(notes, 'all company names mentioned') FROM meetings
#   SELECT PARSE(contract, 'payment terms') FROM documents
#   SELECT PARSE(bio, 'years of experience') FROM takes
#   SELECT PARSE(review, 'specific product complaints') FROM feedback
#
# Returns: VARCHAR - the extracted value(s)

cascade_id: parse_general

description: |
  General-purpose text parser. Extract any information from text using
  natural language instructions. Unlike specialized parsers (PARSE_NAME,
  PARSE_ADDRESS), this function handles arbitrary extraction tasks.

  Uses structural caching: analyzes the input shape and generates a reusable
  SQL expression. Different values with the same shape reuse the cached SQL.

inputs_schema:
  text: The text to parse (or its structural pattern for cache hits)
  instruction: What to extract (free-form natural language)

sql_function:
  name: parse
  description: |
    Extract information from text using natural language instructions.

    Unlike specialized parsers, PARSE() handles any extraction task:
    - Dates and deadlines: PARSE(text, 'deadline date')
    - Names and entities: PARSE(text, 'all person names')
    - Numbers and amounts: PARSE(text, 'total cost')
    - Lists: PARSE(text, 'action items')
    - Specific facts: PARSE(text, 'reason for rejection')

    Returns the extracted value as text. For structured data, returns JSON.
  args:
    - name: text
      type: VARCHAR
      description: The text to parse
    - name: instruction
      type: VARCHAR
      description: What to extract (natural language)
  returns: VARCHAR
  shape: SCALAR
  operators:
    - "PARSE({{ text }}, {{ instruction }})"
    - "{{ text }} PARSE {{ instruction }}"
  cache: true
  output_mode: sql_execute
  cache_key:
    strategy: fingerprint
    fingerprint_args: ["text"]
    fingerprint_config:
      method: hybrid
  test_cases:
    - sql: "SELECT parse('Meeting scheduled for March 15, 2024 at 2pm', 'the date')"
      expect:
        type: contains
        value: "March 15"
      description: "Date extracted from text"
    - sql: "SELECT parse('Contact John Smith at john@acme.com for details', 'email address')"
      expect:
        type: contains
        value: "john@acme.com"
      description: "Email extracted from text"
    - sql: "SELECT parse('The project budget is $50,000', 'budget amount')"
      expect:
        type: contains
        value: "50"
      description: "Amount extracted from text"

cells:
  - name: generate_sql
    instructions: |
      Generate a DuckDB SQL expression that extracts/transforms data from text.

      INPUT TEXT (example of the shape):
      {{ input.text }}

      TASK: {{ input.instruction }}

      OUTPUT: Return ONLY a SQL expression using :text as the input parameter.
      The expression will be executed as: SELECT <your_expression>

      RULES:
      1. Use :text to reference the input value (it will be bound at runtime)
      2. Use DuckDB string functions: trim(), regexp_extract(), regexp_replace(),
         substring(), split_part(), concat(), replace(), upper(), lower(), etc.
      3. For phone formatting, use regexp_replace to normalize and format
      4. For date extraction, use regexp_extract with appropriate patterns
      5. For email extraction, use regexp_extract with email pattern
      6. Return ONLY the SQL expression - no SELECT, no semicolon, no explanation
      7. The expression must work for ANY value with the same structural pattern

      EXAMPLES:

      Input: "  555 123-4567 " | Task: "properly formatted phone number"
      Output: regexp_replace(regexp_replace(trim(:text), '\s+', '-'), '(\d{3})-(\d{3})-(\d{4})', '\1-\2-\3')

      Input: "Call me at john@example.com" | Task: "email address"
      Output: regexp_extract(:text, '([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', 1)

      Input: "Meeting on March 15, 2024" | Task: "the date"
      Output: regexp_extract(:text, '([A-Z][a-z]+ \d{1,2},? \d{4})', 1)

      Input: "Total: $1,234.56" | Task: "the amount"
      Output: regexp_extract(:text, '\$?([\d,]+\.?\d*)', 1)

      Input: "John Smith <john@test.com>" | Task: "person name"
      Output: trim(regexp_extract(:text, '^([^<]+)', 1))

    rules:
      max_turns: 1
