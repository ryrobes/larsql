<h1>Docs</h1>
<p class="lead">
  Stop writing imperative glue code. Start orchestrating agents declaratively.
</p>

<div class="info-box tip">
  <div class="info-box-title">Quick Start</div>
  <p>
    Install with <code>pip install larsql</code> and run your first cascade
    with <code>lars run examples/simple_flow.json --input '{"data": "test"}'</code>
  </p>
</div>

<!-- ═══════════════════════════════════════════════════════════════════════════
     THE PROBLEM
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="the-problem">The Problem Everyone Faces</h2>

<p>
  You start with clean code. Six months later, you're debugging this:
</p>

<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang python">The Retry Hell</span>
  </div>
  <div class="code-block-content">
    <pre><span class="cmt"># The retry loop that ruins every LLM project</span>
<span class="kw">for</span> attempt <span class="kw">in</span> <span class="fn">range</span>(max_retries):
    <span class="kw">try</span>:
        result = llm.call(prompt)
        validation = validate(result)
        <span class="kw">if</span> validation.passed:
            <span class="kw">return</span> result
        <span class="cmt"># Error feedback accumulation</span>
        prompt += <span class="str">f"\n\nError: {validation.error}. Try again."</span>
    <span class="kw">except</span> JSONDecodeError <span class="kw">as</span> e:
        prompt += <span class="str">f"\nFailed to parse JSON: {e}"</span>
    <span class="kw">except</span> ToolCallError <span class="kw">as</span> e:
        prompt += <span class="str">f"\nTool call failed: {e}"</span>

<span class="cmt"># 47 lines later... still doesn't work reliably</span></pre>
  </div>
</div>

<p>
  This is the trajectory of every LLM project. You start clean, add a retry loop,
  add error handling, add context accumulation, add nested conditionals... and suddenly
  you have 2000+ lines of Python with global variables, nested loops, and debugging nightmares.
</p>

<p>(and your cool flow-based graph UI won't help much either - it just visualizes the spaghetti to be more spaghetti like)</p>

<div class="feature-grid">
  <div class="feature-card" style="border-left-color: var(--warning);">
    <h4>Slow</h4>
    <p>Sequential execution - wait for each failure before trying again</p>
  </div>
  <div class="feature-card" style="border-left-color: var(--warning);">
    <h4>Complex</h4>
    <p>Error handling, context accumulation, nested loops, global state</p>
  </div>
  <div class="feature-card" style="border-left-color: var(--warning);">
    <h4>Brittle</h4>
    <p>One random LLM hiccup blocks everything</p>
  </div>
  <div class="feature-card" style="border-left-color: var(--warning);">
    <h4>Low Quality</h4>
    <p>Get whatever attempt N produces, not the best attempt</p>
  </div>
</div>

<p>
  <strong>The fundamental truth:</strong> LLMs fail randomly. JSON parsing errors. Context confusion.
  Tool calling mistakes. You can't eliminate these failures - you have to <em>filter</em> them.
</p>

<!-- ═══════════════════════════════════════════════════════════════════════════
     THE INSIGHT
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="the-insight">The Insight: Stop Retrying, Start Filtering</h2>

<p>
  Instead of fighting errors serially, <strong>run multiple attempts in parallel and filter errors
  out naturally</strong>. This is the core insight behind LARS.
</p>

<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang json">LARS Solution</span>
  </div>
  <div class="code-block-content">
    <pre>{
  <span class="key">"takes"</span>: {
    <span class="key">"factor"</span>: <span class="num">3</span>,
    <span class="key">"evaluator_instructions"</span>: <span class="str">"Pick the best"</span>
  }
}</pre>
  </div>
</div>

<p>
  <strong>What happens:</strong>
</p>
<ol>
  <li>Run 3 attempts <strong>in parallel</strong> (not sequential)</li>
  <li>Random LLM errors <strong>naturally filtered out</strong> by evaluator</li>
  <li>Evaluator picks <strong>THE BEST</strong> of the successes (not just "whatever worked")</li>
  <li>Zero error handling code needed</li>
</ol>

<p>
  <strong>This is genetic algorithms for LLM outputs.</strong> Errors become noise to filter,
  not bugs to debug. The complexity is <em>contained</em> in declarative configuration -
  the spaghetti stays in the bowl.
</p>

<!-- ═══════════════════════════════════════════════════════════════════════════
     THE MATH
     ═══════════════════════════════════════════════════════════════════════════ -->

<h3>The Counterintuitive Economics</h3>

<div class="info-box note">
  <div class="info-box-title">Why Takes Are Faster AND Cheaper</div>
  <table>
    <thead>
      <tr>
        <th>Metric</th>
        <th>Serial Retries</th>
        <th>Takes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Wall time</strong></td>
        <td>6 seconds (sequential)</td>
        <td>3 seconds (parallel)</td>
      </tr>
      <tr>
        <td><strong>Success probability</strong></td>
        <td>97.3% (compound)</td>
        <td>97.3% (independent trials)</td>
      </tr>
      <tr>
        <td><strong>Quality</strong></td>
        <td>"Whatever worked"</td>
        <td>"Best of successes"</td>
      </tr>
      <tr>
        <td><strong>Complexity</strong></td>
        <td>47 lines of error handling</td>
        <td>4 lines of JSON</td>
      </tr>
      <tr>
        <td><strong>Error handling</strong></td>
        <td>Manual (nested try/catch)</td>
        <td>Automatic (filter noise)</td>
      </tr>
    </tbody>
  </table>
</div>

<p>
  With 70% LLM success rate, serial retries give you "the result from attempt 3."
  Takes give you "the best of the 2-3 that succeeded." Same cost, higher quality,
  faster execution.
</p>

<!-- ═══════════════════════════════════════════════════════════════════════════
     WHAT IS LARS
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="what-is-lars">What is LARS?</h2>

<p>
  LARS is a Python framework for building multi-step LLM workflows called <strong>Cascades</strong>.
  Unlike traditional agentic frameworks, LARS treats workflows as <strong>declarative configurations</strong>
  that can mix LLM-powered intelligence with deterministic execution, human-in-the-loop checkpoints,
  and polyglot code cells.
</p>

<h3>Key Philosophy: Encapsulated Complexity</h3>

<p>
  The complexity of agent orchestration is inevitable. The question is where it lives.
  Traditional approaches spread complexity across your codebase - retry loops, error handlers,
  context managers, state machines. LARS <em>encapsulates</em> that complexity inside
  declarative cells.
</p>

<p>
  <strong>No Python loops. No global state. No debugging spaghetti.</strong>
</p>

<p>
  Workflows (Cascades) are composed of <strong>Cells</strong>, where each cell can be:
</p>
<ul>
  <li><strong>LLM-Powered</strong>: Traditional agent execution with tool calling and multi-turn conversations</li>
  <li><strong>Deterministic</strong>: Direct tool invocation without LLM mediation (10-100x faster, $0 cost)</li>
  <li><strong>Polyglot</strong>: Execute SQL, Python, JavaScript, Clojure, or nested cascades</li>
  <li><strong>HITL Screens</strong>: Direct HTML rendering for human-in-the-loop checkpoints</li>
  <li><strong>Hybrid</strong>: Mix all approaches in a single workflow</li>
</ul>

<h3>Built for Iterative Artifact Generation</h3>

<p>
  Unlike LangChain (chatbot-oriented) or AutoGen (agent-to-agent conversations), LARS is designed
  for <strong>monolithic context agents</strong> that iterate on complex tasks:
</p>

<div class="feature-grid">
  <div class="feature-card">
    <div class="feature-card-icon"><iconify-icon icon="mdi:chart-bar"></iconify-icon></div>
    <h4>Data Dashboards</h4>
    <p>Query → Validate → Visualize → Refine</p>
  </div>
  <div class="feature-card">
    <div class="feature-card-icon magenta"><iconify-icon icon="mdi:file-document"></iconify-icon></div>
    <h4>Report Generation</h4>
    <p>Research → Draft → Critique → Polish</p>
  </div>
  <div class="feature-card">
    <div class="feature-card-icon green"><iconify-icon icon="mdi:code-braces"></iconify-icon></div>
    <h4>Code Generation</h4>
    <p>Explore → Implement → Test → Optimize</p>
  </div>
  <div class="feature-card">
    <div class="feature-card-icon purple"><iconify-icon icon="mdi:palette"></iconify-icon></div>
    <h4>Design Systems</h4>
    <p>Generate → Render → Critique → Iterate</p>
  </div>
</div>

<!-- ═══════════════════════════════════════════════════════════════════════════
     FIVE SELF-* PROPERTIES
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="five-properties">The Five Self-* Properties</h2>
<p>LARS implements five self-improving capabilities:</p>

<div class="feature-grid">
  <div class="feature-card">
    <div class="feature-card-icon"><iconify-icon icon="mdi:robot-outline"></iconify-icon></div>
    <h4>Self-Orchestrating</h4>
    <p><strong>Manifest/Quartermaster</strong> - workflows dynamically select tools based on context</p>
  </div>
  <div class="feature-card">
    <div class="feature-card-icon magenta"><iconify-icon icon="mdi:test-tube"></iconify-icon></div>
    <h4>Self-Testing</h4>
    <p><strong>Snapshot system</strong> - tests write themselves from real executions</p>
  </div>
  <div class="feature-card">
    <div class="feature-card-icon green"><iconify-icon icon="mdi:chart-line"></iconify-icon></div>
    <h4>Self-Optimizing</h4>
    <p><strong>Passive optimization</strong> - prompts improve automatically from usage data</p>
  </div>
  <div class="feature-card">
    <div class="feature-card-icon purple"><iconify-icon icon="mdi:wrench-outline"></iconify-icon></div>
    <h4>Self-Healing</h4>
    <p><strong>Auto-fix</strong> - failed cells debug and repair themselves with LLM assistance</p>
  </div>
</div>

<div class="feature-grid" style="grid-template-columns: 1fr;">
  <div class="feature-card">
    <div class="feature-card-icon"><iconify-icon icon="mdi:creation"></iconify-icon></div>
    <h4>Self-Building</h4>
    <p><strong>Calliope</strong> - workflows constructed through natural language conversation</p>
  </div>
</div>

<!-- ═══════════════════════════════════════════════════════════════════════════
     CORE ARCHITECTURE
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="architecture">Core Architecture</h2>

<h3>Cascades (Workflows)</h3>
<p>
  Cascades are JSON/YAML files that define multi-step workflows. Each cascade consists of:
</p>
<ul>
  <li><strong>Metadata</strong>: ID, description, and input schema</li>
  <li><strong>Cells</strong>: Individual execution stages with their own configuration</li>
  <li><strong>State</strong>: Shared session state accessible across cells</li>
  <li><strong>Handoffs</strong>: Dynamic routing between cells</li>
</ul>

<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang yaml">YAML Example</span>
  </div>
  <div class="code-block-content">
    <pre><span class="key">cascade_id</span>: dashboard_autopilot
<span class="key">description</span>: Generate and refine data dashboards

<span class="key">cells</span>:
  - <span class="key">name</span>: generate_dashboard
    <span class="key">instructions</span>: <span class="str">"Create a sales dashboard from the database"</span>
    <span class="key">skills</span>:
      - smart_sql_run
      - create_chart
    <span class="key">takes</span>:
      <span class="key">factor</span>: <span class="num">3</span>
      <span class="key">evaluator_instructions</span>: <span class="str">"Pick the most insightful dashboard"</span>
      <span class="key">reforge</span>:
        <span class="key">steps</span>: <span class="num">2</span>
        <span class="key">honing_prompt</span>: <span class="str">"Improve visual clarity, data accuracy, accessibility"</span>
    <span class="key">wards</span>:
      <span class="key">post</span>:
        - <span class="key">validator</span>: data_accuracy
          <span class="key">mode</span>: blocking
        - <span class="key">validator</span>: accessibility_check
          <span class="key">mode</span>: retry
          <span class="key">max_attempts</span>: <span class="num">2</span>
    <span class="key">handoffs</span>: [review]

  - <span class="key">name</span>: review
    <span class="key">instructions</span>: <span class="str">"Present dashboard for final approval"</span>
    <span class="key">context</span>:
      <span class="key">from</span>: [generate_dashboard]</pre>
  </div>
</div>

<p>
  <strong>What this does:</strong>
</p>
<ol>
  <li><strong>Takes:</strong> Generate 3 dashboard variations in parallel, pick the best</li>
  <li><strong>Wards:</strong> Block on data errors, retry on accessibility issues</li>
  <li><strong>Reforge:</strong> Iteratively refine the winner with vision feedback + mutations</li>
  <li><strong>Observability:</strong> Full execution trace, Mermaid graphs, real-time SSE events</li>
</ol>

<h3>Cell Types</h3>
<p>
  Cells are the atomic units of execution. LARS supports four primary cell types:
</p>

<table>
  <thead>
    <tr>
      <th>Cell Type</th>
      <th>Configuration</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>LLM Cells</strong></td>
      <td><code>instructions</code> + <code>skills</code></td>
      <td>Agent tasks with tool calling</td>
    </tr>
    <tr>
      <td><strong>Deterministic Cells</strong></td>
      <td><code>tool</code> + <code>tool_inputs</code></td>
      <td>Direct tool execution without LLM</td>
    </tr>
    <tr>
      <td><strong>HITL Screen Cells</strong></td>
      <td><code>htmx</code> (HTML template)</td>
      <td>Human approval checkpoints</td>
    </tr>
    <tr>
      <td><strong>SQL Mapping Cells</strong></td>
      <td><code>for_each_row</code></td>
      <td>Process each row from a query</td>
    </tr>
  </tbody>
</table>

<!-- ═══════════════════════════════════════════════════════════════════════════
     INSTALLATION
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="installation">Installation</h2>

<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang bash">Bash</span>
  </div>
  <div class="code-block-content">
    <pre><span class="cmt"># Basic installation</span>
pip install larsql

<span class="cmt"># With local models support</span>
pip install larsql[local-models]

<span class="cmt"># From source</span>
git clone https://github.com/ryrobes/lars
cd lars/lars
pip install -e .</pre>
  </div>
</div>

<h3>Required Environment Variables</h3>
<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang config">Environment</span>
  </div>
  <div class="code-block-content">
    <pre><span class="cmt"># LLM Provider (OpenRouter is default)</span>
<span class="key">OPENROUTER_API_KEY</span>=<span class="str">sk-or-...</span>

<span class="cmt"># ClickHouse (Required for logging and SQL features)</span>
<span class="key">LARS_CLICKHOUSE_HOST</span>=<span class="str">localhost</span>
<span class="key">LARS_CLICKHOUSE_PORT</span>=<span class="num">9000</span>
<span class="key">LARS_CLICKHOUSE_DATABASE</span>=<span class="str">lars</span>
<span class="key">LARS_CLICKHOUSE_USER</span>=<span class="str">lars</span>      <span class="cmt"># Default: lars</span>
<span class="key">LARS_CLICKHOUSE_PASSWORD</span>=<span class="str">lars</span>  <span class="cmt"># Default: lars</span>

<span class="cmt"># Optional: Customize models</span>
<span class="key">LARS_DEFAULT_MODEL</span>=<span class="str">x-ai/grok-4.1-fast</span>
<span class="key">LARS_DEFAULT_EMBED_MODEL</span>=<span class="str">qwen/qwen3-embedding-8b</span></pre>
  </div>
</div>

<div class="info-box warning">
  <div class="info-box-title">Required Infrastructure</div>
  <p>
    LARS requires a running ClickHouse instance. There is no embedded fallback.
    See the <a href="https://clickhouse.com/docs/en/getting-started/install" target="_blank">ClickHouse installation guide</a>
    to set up locally.
  </p>
</div>

<!-- ═══════════════════════════════════════════════════════════════════════════
     QUICK START
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="quickstart">Quick Start Examples</h2>

<h3>1. Run a Cascade</h3>
<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang cli">CLI</span>
  </div>
  <div class="code-block-content">
    <pre><span class="cmt"># Run with inline JSON input</span>
lars run examples/simple_flow.json --input <span class="str">'{"data": "test"}'</span>

<span class="cmt"># Run with input file</span>
lars run examples/simple_flow.json --input input.json

<span class="cmt"># Run with specific session ID</span>
lars run examples/simple_flow.json \
  --input <span class="str">'{"key": "value"}'</span> \
  --session my_session_123</pre>
  </div>
</div>

<h3>2. Query Execution Logs</h3>
<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang">SQL via CLI</span>
  </div>
  <div class="code-block-content">
    <pre><span class="cmt"># Query ClickHouse via CLI</span>
lars sql query <span class="str">"SELECT COUNT(*) FROM all_data"</span>

<span class="cmt"># View recent sessions with costs</span>
lars sql query <span class="str">"SELECT session_id, phase_name, cost
  FROM all_data
  WHERE cost > 0
  LIMIT 10"</span>

<span class="cmt"># Export to JSON</span>
lars sql query <span class="str">"SELECT * FROM all_data LIMIT 5"</span> --format json</pre>
  </div>
</div>

<h3>3. Launch Studio Web UI</h3>
<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang">Web Dashboard</span>
  </div>
  <div class="code-block-content">
    <pre><span class="cmt"># Production mode</span>
lars serve studio --port 5050

<span class="cmt"># Development mode (hot reload)</span>
lars serve studio --dev

<span class="cmt"># Access at http://localhost:5050</span>
<span class="cmt"># Features:</span>
<span class="cmt">#   - /sql-query: SQL IDE + Polyglot Notebooks</span>
<span class="cmt">#   - /playground: Visual cascade builder</span>
<span class="cmt">#   - /sessions: Session explorer</span>
<span class="cmt">#   - /calliope: Conversational cascade builder</span></pre>
  </div>
</div>

<!-- ═══════════════════════════════════════════════════════════════════════════
     SEMANTIC SQL
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="semantic-sql">Semantic SQL</h2>
<p>
  One of LARS's most powerful features is <strong>Semantic SQL</strong> -
  the ability to use natural language and LLM-powered functions directly in SQL queries.
</p>

<div class="code-block">
  <div class="code-block-header">
    <span class="code-block-lang">Semantic SQL Examples</span>
  </div>
  <div class="code-block-content">
    <pre><span class="cmt">-- Vector search with natural language</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> docs
<span class="kw">WHERE</span> title <span class="fn">SIMILAR_TO</span> <span class="str">'sustainability report'</span>
<span class="kw">LIMIT</span> <span class="num">10</span>;

<span class="cmt">-- LLM aggregation</span>
<span class="kw">SELECT</span>
  category,
  <span class="fn">LLM_SUMMARIZE</span>(text) <span class="kw">AS</span> summary
<span class="kw">FROM</span> articles
<span class="kw">GROUP BY</span> category;

<span class="cmt">-- Semantic grouping</span>
<span class="kw">SELECT</span>
  <span class="fn">topics</span>(title, <span class="num">5</span>) <span class="kw">AS</span> topic,
  <span class="kw">COUNT</span>(*) <span class="kw">AS</span> count
<span class="kw">FROM</span> documents
<span class="kw">GROUP BY</span> topic;</pre>
  </div>
</div>

<p>
  These operators are powered by <strong>cascade-driven rewrites</strong>.
  You can even create custom operators without modifying Python code -
  just define a cascade file with operator patterns!
</p>

<!-- ═══════════════════════════════════════════════════════════════════════════
     NEXT STEPS
     ═══════════════════════════════════════════════════════════════════════════ -->

<h2 id="next">Next Steps</h2>
<p>Explore the documentation to learn more:</p>
<ul>
  <li><a href="#core-concepts" data-link>Core Concepts</a> - Understand Cascades, Cells, State, and Context</li>
  <li><a href="#cascade-dsl" data-link>Cascade DSL Reference</a> - Complete configuration guide</li>
  <li><a href="#cell-types" data-link>Cell Types</a> - Deep dive into LLM, Deterministic, HITL, and Polyglot cells</li>
  <li><a href="#semantic-sql" data-link>Semantic SQL</a> - Learn about SQL operators and rewrites</li>
  <li><a href="#takes" data-link>Takes & Evaluation</a> - Parallel execution and multi-model benchmarking</li>
  <li><a href="#tools" data-link>Tools (Skills)</a> - Six types of tools and how to create custom ones</li>
</ul>
