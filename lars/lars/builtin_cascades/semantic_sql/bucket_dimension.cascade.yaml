cascade_id: bucket_dimension
internal: true
description: 'General-purpose classifier dimension. Classifies text into user-specified

  buckets/categories provided as a comma-separated list.


  Unlike CATEGORY (which can auto-detect categories), BUCKET requires explicit

  categories - perfect when you know exactly what buckets you want.


  This is a DIMENSION-shaped function for use in GROUP BY clauses.

  '
inputs_schema:
  texts: JSON array of all text values to analyze
  buckets: Comma-separated list of bucket/category names (REQUIRED)
  strict: If true, only use exact bucket names; if false, allow Other (default false)
sql_function:
  name: bucket
  description: 'Classify text into user-specified buckets. REQUIRES a comma-separated

    list of bucket names as the second argument.

    '
  shape: DIMENSION
  mode: mapping
  args:
  - name: text
    type: VARCHAR
    role: dimension_source
  - name: buckets
    type: VARCHAR
    description: Comma-separated list of bucket names (e.g., 'Tech, Finance, Health')
  - name: strict
    type: BOOLEAN
    default: false
    description: If true, force all items into provided buckets; if false, allow "Other"
  returns: VARCHAR
  cache: true
  test_cases:
  - sql: SELECT bucket(75, 'numeric')
    expect:
      type: regex
      pattern: .+
    description: Value bucketed
cells:
- name: classify_into_buckets
  model: google/gemini-2.5-flash-lite
  instructions: "Classify these {{ input.texts | length }} texts into the specified\
    \ buckets.\n\nBUCKETS TO USE:\n{% for bucket in input.buckets.split(',') %}\n\
    - {{ bucket | trim }}\n{% endfor %}\n{% if not input.strict %}\n- Other (for items\
    \ that don't clearly fit the above)\n{% endif %}\n\nTexts to classify (with index\
    \ numbers):\n{% for v in input.texts %}\n[{{ loop.index0 }}] \"{{ v[:500] | replace('\"\
    ', '\\\\\"') }}\"\n{% endfor %}\n\nReturn a JSON object mapping each text's INDEX\
    \ NUMBER to its bucket:\n\n{\n  \"mapping\": {\n    \"0\": \"Bucket Name\",\n\
    \    \"1\": \"Bucket Name\",\n    ...\n  }\n}\n\nRULES:\n- Use the INDEX NUMBER\
    \ (0, 1, 2, ...) as keys, NOT the original text\n- Every text must be assigned\
    \ to exactly ONE bucket\n- Use ONLY the bucket names provided above (case-sensitive)\n\
    {% if input.strict %}\n- STRICT MODE: You must use one of the specified buckets,\
    \ no exceptions\n{% else %}\n- Use \"Other\" only if the text genuinely doesn't\
    \ fit any specified bucket\n{% endif %}\n- Return ONLY the JSON object\n"
  rules:
    max_turns: 1
    max_attempts: 3
  output_schema:
    type: object
    properties:
      mapping:
        type: object
    required:
    - mapping
